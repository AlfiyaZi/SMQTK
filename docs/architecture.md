# SMQTK Architecture Overview

SMQTK is mainly comprised of 3 high level components, with additional sub-modules for tests, utilities and other control structures.

* Data abstraction interfaces and plugin implementations
* Algorithm abstraction interfaces and plugin implementations
* [Web services](python/smqtk/web) and utility [scripts](bin)/[modules](python/smqtk/utils) that use and are used by both of the above

Each of these main components are housed within distinct sub-modules under ``smqtk`` and adhere to a plugin pattern for the dynamic discovery of implementations.


## Data Abstraction
An important part of any algorithm is the data its working over and the data that it produces.
An important part of working with large scales of data is where the data is stored and how its accessed.
The ``smqtk.representation`` module contains interfaces and plugins for various core data structures, allowing plugin implementations to decide where and how the underlying raw data should be stored and accessed.
This potentially allows algorithms to handle more data that would otherwise be feasible on a single machine.


### Data Representation Structures
The following are the core data representation interfaces.
Each bullet links to the source file in which the interface is defined, which contains more documentation on the intent and function of its high level functionality.

* [``CodeIndex``](python/smqtk/representation/code_index/__init__.py)
    * Mapping structure from a bit-code (represented as a python ``integer`` or ``long``) to one or more associated ``DescriptorElement`` instances.
* [``DataElement``](python/smqtk/representation/data_element/__init__.py)
    * High level interface to media content.
* [``DataSet``](python/smqtk/representation/data_set/__init__.py)
    * Set-based container for ``DataElement`` instances.
* [``DescriptorElement``](python/smqtk/representation/descriptor_element/__init__.py)
    * Container for an arbitrary descriptor vector, or more simply, a vector of floating point values.

It is required that implementations have a common serialization format so that they may be stored or transported by other structures in a general way without caring what the specific implementation is.
For this we require that all implementations be serializable via the ``pickle`` (and thus ``cPickle``) module functions.


### Data Support Structures
Other data structures are provided in the [``smqtk.representation``](python/smqtk/representation) module to assist with the use of the above described structures:

* [``DescriptorElementFactory``](python/smqtk/representation/descriptor_element_factory.py)
    * Factory object for producing ``DescriptorElement`` instances given a type and uuid.
    * Used for when something knows it wants to produce ``DescriptorElement`` instances without caring what specific implementation of ``DescriptorElement`` is being produced.


## Algorithm Interfaces
Algorithm interfaces provided:

* [``DescriptorGenerator``](python/smqtk/algorithms/descriptor_generator__init__.py)
    * Algorithms that generate a single ``DescriptorElement`` per input ``DataElement``.
    * Implementations are constrained to some set of data content types they know how to handle.
* [``NearestNeighborsIndex``](python/smqtk/algorithms/nn_index/__init__.py)
    * Algorithms that solve the k-nearest-neighbors problem over some build index of ``DescriptorElements`` generated by some ``DescriptorGenerator``.
* [``RelevancyIndex``](python/smqtk/algorithms/relevancy_index/__init__.py)
    * Algorithms that rank an index of ``DescriptorElement`` instances based on provided positive and negative example ``DescriptorElement`` instances.


## Utilities and Applications
Also part of SMQTK are support utility modules, utility scripts (effectively the "binaries") and service-oriented and demonstration web applications.

### Utility Modules
Various unclassified functionality intended to support the primary goals of SMQTK.
See doc-string comments on sub-module classes and functions in [``smqtk.utils``](python/smqtk/utils) module.

### Utility Scripts
Located in the [``bin``](bin) directory are various scripts intended to provide quick access or generic entry points to common SMQTK functionality.
These scripts generally require configuration via a JSON text file.
By rule of thumb, scripts that require a configuration also provide an option for outputting a default or example configuration file.

Currently available utility scripts:
* [``computeDescriptor.py``](bin/computeDescriptor.py)
    * Compute a content descriptor vector for a given media file.
* [``createFileIngest.py``](bin/createFileIngest.py)
    * Add local file data as ``DataFileElement`` instances (a plugin implementation of the ``DataElement`` interface) to a configured ``DataSet``.
* [``removeOldFiles.py``](bin/removeOldFiles.py)
    * Utility to recursively scan and remove files underneath a given directory if they have not been modified for longer than a set amount of time.
    * Created to remove cached files so a long-running web service doesn't overwhelm the file-system over time.
* [``runApplication.py``](bin/runApplication.py)
    * Generic entry point for running SMQTK web applications defined in [``smqtk.web``](python/smqtk/web).

### Web Service and Demonstration Applications
Included in SMQTK are a few web-based service and demonstration applications, providing a view into the functionality provided by SMQTK algorithms and utilities.
Web services should be runnable via the ``bin/runApplication.py`` script.
Web applications are located under the plug-able module ``smqtk.web``.

* [Descriptor Similarity Service](python/smqtk/web/descriptor_service/__init__.py)
    * Provides a web-accessible API for computing content descriptor vectors for available descriptor generator labels.
    * Descriptor generators that are available to the service are based on the a configuration file provided to the server.


## Plugin Architecture
In SMQTK, data structures and algorithms are first defined by an abstract interface class that lays out what that services the data structure, or methods that the algorithm, should provide.
This allows users to treat instances of structures and algorithms in a generic way, based on their defined high level functionality, without needing to knowing what specific implementation is running underneath.
It lies, of course, to the implementations of these interfaces to provide the concrete functionality.

When creating a new data structure or algorithm interface, the pattern is that each interface is defined inside its own sub-module in the ``__init__.py`` file.
This file also defines a function ``get_..._impls()`` (replacing the ``...`` with the name of the interface) that returns a mapping of implementation class names to the implementation class type, by calling the general helper method [``smqtk.utils.plugin.get_plugins``](python/smqtk/utils/plugin.py).
This helper method looks for modules defined parallel to the ``__init__.py`` file and extracts classes that extend from the specified interface class as specified by a specified helper variable or by matching the file's name to a contained class name.
See the doc-string of [``smqtk.utils.plugin.get_plugins``](python/smqtk/utils/plugin.py) for more information on how plugin modules are discovered.

### Adding a new Interface and Implementation
For example, lets say we're creating a new data structure interface called ``FooBar``.
We would create a directory and ``__init__.py`` file (python module) to house the interface as follows:

```sh
python/
└── smqtk/
    └── representation/
        └── foo_bar/          # new
            └── __init__.py   # new
```

The ``__init__.py`` file might look something like the following, defining a new abstract class (sets or descends from something that sets ``__metaclass__ = abc.ABCMeta``):

```python
import abc
from smqtk.utils.configurable_interface import Configurable

class FooBar (Configurable):
    """
    Some documentation on what this does.
    """
    # Interface methods and/or abstract functionality here

def get_foo_bar_impls(reload_modules=False):
    import os.path as osp
    from smqtk.utils.plugin import get_plugins
    this_dir = osp.abspath(osp.dirname(__file__))
    helper_var = 'FOO_BAR_CLASS'
    return get_plugins(__name__, this_dir, helper_var, CodeIndex, None,
                       reload_modules)
```

In order to allow for implementations of an interface to to be configurable, as well allowing for implementations used to be determined at configuration time, new interfaces should descend from the ``Configurable`` interface class.
This interface class sets ``__metaclass__ = abc.ABCMeta``, thus it is not set in the example above.

When adding a an implementation class, if it is sufficient to be contained in a single file, a new module can be added like:

```sh
python/
└── smqtk/
    └── representation/
        └── foo_bar/
            ├── __init__.py
            └── some_impl.py  # new
```

Where ``some_impl.py`` might look like:

```python
from smqtk.representation.foo_bar import FooBar

class SomeImpl (FooBar):
    """
    Some documentation
    """
    # Implementation of some stuff

FOO_BAR_CLASS = SomeImpl
```

It is important to note the ``FOO_BAR_CLASS = SomeImpl`` line (where ``FOO_BAR_CLASS`` is what is specified to the ``helper_var`` in the ``get_foo_bar_impls`` function).
This is important to include because this allows the plugin helper to know what class to import (or multiple classes if its set to an iterable).

Implementation classes can also live inside of a nested sub-module.
This is useful when an implementation class requires extensive, specific support utilities (for example, see the ``DescriptorGenerator`` implementation [``ColorDescriptor``](python/smqtk/algorithms/descriptor_generator/colordescriptor)).

```sh
python/
└── smqtk/
    └── representation/
        └── foo_bar/
            ├── __init__.py
            ├── some_impl.py
            └── other_impl/      # new
                └── __init__.py  # new
```

Where the ``__init__.py`` file should at least define the helper variable reference to implementation classes that should be exported.


###### Reload Use Warning
While the [``smqtk.utils.plugin.get_plugins``](python/smqtk/utils/plugin.py) function allows for reloading discovered modules for potentially new content, this is not recommended under normal conditions.
When reloading a plugin module after ``pickle`` serializing an instance of an implementation, deserialization causes an error because the original class type that was pickled is no longer valid as the reloaded model overwrote the previous plugin class type.
